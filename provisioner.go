package main

import (
    "context"
    "fmt"
    "os"

    "github.com/hashicorp/packer-plugin-sdk/plugin"
    packersdk "github.com/hashicorp/packer-plugin-sdk/packer"

    // for HCL2 schema & decoding
    "github.com/hashicorp/hcl/v2/hcldec"
    config "github.com/hashicorp/packer-plugin-sdk/template/config"
)

type Provisioner struct {
    config Config
    client *AAPClient
}

func main() {
    pps := plugin.NewSet()
    pps.RegisterProvisioner("ansible-aap", new(Provisioner))
    if err := pps.Run(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

// 1) Define your HCL schema
func (p *Provisioner) ConfigSpec() hcldec.ObjectSpec {
    // FlatMapstructure is generated by `packer-sdc mapstructure-to-hcl2`
    return p.config.FlatMapstructure().HCL2Spec()
}

// 2) Decode raw HCL into p.config, then validate
func (p *Provisioner) Prepare(raws ...interface{}) error {
    if err := config.Decode(&p.config, &config.DecodeOpts{
        PluginType:  "provisioner",
        Interpolate: true,
    }, raws...); err != nil {
        return err
    }
    return p.config.Validate()
}

// 3) Initialize any clients you need
func (p *Provisioner) Configure(_ ...interface{}) error {
    p.client = NewAAPClient(p.config)
    return nil
}

func (p *Provisioner) Provision(
    ctx context.Context,
    ui packersdk.Ui,
    comm packersdk.Communicator,
    generatedData map[string]interface{},
) error {
    // 1) You can pull any of the communicator‐generated values out of generatedData
    //    (e.g. Host, Port, User, SSHPrivateKeyFile, etc.)
    //
    // 2) Use those to build your dynamic inventory, call your AAP client, poll, cleanup...
    //
    // 3) Surface errors via `ui.Error(err.Error())` and return err
    //
    // 4) When everything succeeds, just return nil:
    ui.Message("AAP run completed")
    return nil
}

// 5) A no‐op Cancel
func (p *Provisioner) Cancel() error {
    return nil
}